# 整体思路

[toc]

## 初始化
1. 获取容器宽度，获取图片宽度，获取列数，获取间隙，
``` js
urls = [
    "./img/0.jpg",
    "./img/1.jpg",
    ...
]

//封装document.querySelector();
function $(selector) {
    return document.querySelector(selector);
}

// 1. 获取容器
var positionBox = $(".position-box");
```
2. 创建图片元素，循环加入容器中。
``` js
var init = function () {
    //创建li加入图片
    function _createDiv(i) {
        var div = document.createElement("div");
        div.innerHTML = "<img src=" + i + " alt=''>";
        positionBox.appendChild(div);
    }
    //循环所有图片
    for (var i = 0; i < urls.length; i++) {
        //放入图片
        _createDiv(urls[i]);
    }

    /* console.log($(".position-box > div").offsetWidth); => 0;
    div获取不到宽度是因为图片没有加载完成，并且div有positionabsolut，所以宽度只能是0。
    注释掉div元素的position:absolute后，因为是常规流，块盒默认宽度是100%， 所以获取到了。 img元素宽度还是没加载出来所以获取到img 还是0 
    */
}
init();
```
3. 当图片加载完成后，创建一个方法，排列每一张图
    - 需要知道列数 = Math.floor(总宽 / 图片宽度);
    - 总间隙 = 总宽度 - (列数 * 图片宽度)
    - 需要平分间隙的列数 = 列数 - 1;
    - 每个间隙 = 总间隙 / 需要平分间隙的列数
4. 创建数组，保存每一列的高度。
    - 数组长度为列数，初始值为0，用 数组.fill(0) 方法填充值。
``` js
//获取图片宽度
    var imgW = $(".position-box > div > img").clientWidth
    // 没有间隙的列数 = 宽度 / 图片宽度
    var cols = Math.floor(positionBox.clientWidth / imgW);
    // 剩下的间隙 = 宽度 - 图片宽度 * 没有间隙的列数
    var gaps = positionBox.clientWidth - imgW * cols;
    // 每个间隙的宽度 = 剩下间隙宽度 / (列数 - 1);
    var gap = gaps / (cols - 1);
    //获取子元素
    var divLen = positionBox.children;
    //空数组
    var rowsArr = new Array(cols);
    rowsArr.fill(0);
    //计数器变量
    var count = 0;
    //高度最小下标
    var newCount = 0;
    //总高度
    var height = 0;
    //位置
    var left,top;
```
5. 计算每一张图片的 top
    - top值为列数长度中最小值
    - 然后改变当前列新的高度。
    - 找当前最小值对应的下标，把下标数组的值+= 当前图片的高度 + 间隙
6. 用上面获取的下标index，计算图片的 left
    - left = index * 间隙 + index * 图片的宽度
7. 因为图片是绝对定位，所以容器没有高度， 计算列中最大值高度
``` js
// 3. 创建一个数组，循环列数， 往数组里存现在每个列的高度。
for(let i = 0; i < urls.length; i++){
    //比较列的最小高度
    for(var j = 0; j < cols; j++){
        if(rowsArr[j] < rowsArr[newCount]){
            newCount = j;
        }
    }

    //计算left
    left = newCount * imgW + newCount * gap;
    //计算top
    top = rowsArr[newCount];
    //设置位置
    divLen[i].style.top = top + "px";
    divLen[i].style.left = left + "px";

    //更新添加的数组列
    rowsArr[newCount] += divLen[i].offsetHeight + gap - 1;

    //总高度
    //比较列的最大高度
    var max = rowsArr[0];
    for(var k = 0; k < cols; k++){
        if(rowsArr[k] > max){
            max = rowsArr[k];
        }
    }
    height = max;
    //设置高度
    positionBox.style.height = height + "px";
    
    //debugger;

    //计数器
    if(count === cols - 1){
        count = 0;
    }else{
        count++;
    }
}
```
8. window.onresize 时，用防抖函数，调用重排图片。
``` js
var timeId = null;
window.onresize = function(){
    if(timeId){
        clearTimeout(timeId);
    }
    timeId = setTimeout(function(){
        calculation();
    }, 500)
}
```


## 知识点

1. 字符串模板语法 es6
    - 会自动解析${i}
``` js
for(var i = 0; i < 10; i++){
    var src = `./img/${i}.jpg`
}
```

2. es6 对象的键值对中，键和值变量名都是一样的，就可以缩写
``` js
var a = 0;
var b = 0;
var obj = {
    a : a,
    b : b,
}
//es6 缩写
=>  var obj = {
        a,
        b,
    }
```

3. 给空数组填充值 数组.fill()
``` js
var arr = new Array(5);
arr.fill(0);
```

4. es6方法 找数组中最小值 
``` js
// 1. 
Math.min.apply(null, arr);
// 2. 
Math.min(...arr);
```

5. css过度 transition
``` css
div{transition:all 0.3s ease;width:100px;height:100px;background:red;}
div:hover{height:500px;}
```

### 防抖函数

var timeId = null;
window.onresize = function(){
	if(timeId){
		clearTimeout(timeId);
	}
	timeId = setTimeout(function(){
		执行体
	}, 500)
}